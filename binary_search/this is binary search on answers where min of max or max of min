Note 
to solve this type of questions we need to just make a binary search in answer which is min of maximum like this something is given and inside that while loop we have to use a for loop to iterate on the whole array


AGGRCOW - Aggressive cows
#binary-search
Farmer John has built a new long barn, with N (2 <= N <= 100,000) stalls. The stalls are located along a straight line at positions x1 ... xN (0 <= xi <= 1,000,000,000).

His C (2 <= C <= N) cows don't like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ wants to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?
Input
t – the number of test cases, then t test cases follows.
* Line 1: Two space-separated integers: N and C
* Lines 2..N+1: Line i+1 contains an integer stall location, xi
Output
For each test case output one integer: the largest minimum distance.
Example
Input:

1
5 3
1
2
8
4
9
Output:

3


Approach:
in this case we have to try for each distances from 1 to max value we have to try for binary search
import java.util.*;
always prefer to sort the array
Code:

public class Codeforces {
    public static boolean isValid(int arr[], int mid, int c){
        int cows = 1;
        int prev = arr[0];
        for(int i = 1; i < arr.length; i++){
            if(arr[i] - prev >= mid){
                prev = arr[i];
                cows++;
            }
            if(cows >= c){
                return true;
            }
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while(t-- > 0){
            int n = sc.nextInt();
            int c = sc.nextInt();
            int arr[] = new int[n];
            for(int i = 0; i < n; i++){
                arr[i] = sc.nextInt();
            }
            Arrays.sort(arr);
            int start = 1;
            int ans = 0;
            int end = Arrays.stream(arr).max().getAsInt();
            while (start <= end){
                int mid = start + (end-start)/2;
                if(isValid(arr, mid, c)){
                    start = mid+1;
                    ans = mid;
                }
                else{
                    end = mid-1;
                }
            }
            System.out.println(ans);
        }
    }
}

2064. Minimized Maximum of Products Distributed to Any Store
You are given an integer n indicating there are n specialty retail stores. There are m product types of varying amounts, which are given as a 0-indexed integer array quantities, where quantities[i] represents the number of products of the ith product type.

You need to distribute all products to the retail stores following these rules:

A store can only be given at most one product type but can be given any amount of it.
After distribution, each store will have been given some number of products (possibly 0). Let x represent the maximum number of products given to any store. You want x to be as small as possible, i.e., you want to minimize the maximum number of products that are given to any store.
Return the minimum possible x.

 

Example 1:

Input: n = 6, quantities = [11,6]
Output: 3
Explanation: One optimal way is:
- The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3
- The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3
The maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) = 3.


code:
class Solution {
    public boolean isPossible(int mid, int temp, int quantities[], int len){
        int ans = 0;
        for(int i = 0; i < len; i++){
            int div = (int)Math.ceil((double)quantities[i]/mid);
            ans += div;
        }
        if(ans <= temp){
            return true;
        }
        return false;
    }
    public int minimizedMaximum(int n, int[] quantities) {
        int start = 1;
        int len = quantities.length;
        int ans = Integer.MAX_VALUE;
        int end = Arrays.stream(quantities).max().getAsInt();
        while(start <= end){
            int mid = start + (end - start)/2;
            int temp = n;
            if(isPossible(mid, temp, quantities, len)){
                ans = Math.min(ans, mid);
                end = mid-1;
            }
            else{
                start = mid+1;
            }
        }
        return ans;
    }
}
// this is same as aggresive cows
1552. Magnetic Force Between Two Balls

code:
class Solution {
    public boolean possible(int mid, int position[], int m){
        int prev = position[0];
        int balls = 1;
        for(int i = 1; i < position.length; i++){
            if((position[i]-prev) >= mid){
                prev = position[i];
                balls++;
            }
            if(balls >= m){
                return true;
            }
        }
        return false;
    }
    public int maxDistance(int[] position, int m) {
        int n = position.length;
        Arrays.sort(position);
        int ans = Integer.MIN_VALUE;
        int start = 1;
        int end = Arrays.stream(position).max().getAsInt();
        while(start <= end){
            // System.out.println(start+" "+end);
            int mid = start + (end-start)/2;
            if(possible(mid, position, m)){
                start = mid+1;
                ans = Math.max(mid, ans);
            }
            else{
                end = mid-1;
            }
        }
        return ans;
    }
}



2187. Minimum Time to Complete Trips

code:
class Solution {
    public long minimumTime(int[] time, int totalTrips) {
        long start = 1L;
        long maxTime = 0L;
        for (int t : time) {
            maxTime = Math.max(maxTime, (long)t);
        }
        long end = maxTime * (long) totalTrips;
        System.out.println(end);
        long ans = end;
        while(start <= end){
            long mid = start + (end-start)/2;
            long total = 0;
            for(int i = 0; i < time.length; i++){
                total += mid/time[i];
                if(total >= totalTrips) break;
            }
            if(total >= totalTrips){
                end = mid-1;
                ans = Math.min(ans, mid);
            }
            else{
                start = mid+1;
            }
        }
        return ans;
    }
}




Problem statement
book allocation problem, painters partition, split array largest sum all of these question uses the same concepts
Given an array ‘arr’ of integer numbers, ‘arr[i]’ represents the number of pages in the ‘i-th’ book.



There are ‘m’ number of students, and the task is to allocate all the books to the students.



Allocate books in such a way that:

1. Each student gets at least one book.
2. Each book should be allocated to only one student.
3. Book allocation should be in a contiguous manner.


You have to allocate the book to ‘m’ students such that the maximum number of pages assigned to a student is minimum.



If the allocation of books is not possible, return -1.


Sample Input 1:
4 2
12 34 67 90
Sample Output 1:
113

code:
import java.util.ArrayList;
public class Solution {
    public static int isPossiible(int pages, ArrayList<Integer> al){
        int count = 1;
        int sum = 0;
        for(int i = 0; i < al.size(); i++){
            if((sum + al.get(i)) <= pages){
                sum += al.get(i);
            }
            else{
                sum = al.get(i);
                count++;
            }
        }

        // System.out.println(count+" "+pages);
        // if(count == m){
        //     return true;
        // }
        // return false;
        return count;
    }
    public static int findPages(ArrayList<Integer> arr, int n, int m) {
        // Write your code here.
        if(arr.size() < m){
            return -1;
        }
        int start = 0;
        int end =  0;
        int ans = 0;
        for(int i = 0; i < arr.size(); i++){
            if(arr.get(i) > start){
                start = arr.get(i);
            }
            end += arr.get(i);
        }
        // System.out.println(start+" "+end);
        while(start <= end){
            int mid = start + (end-start)/2;
            int count = isPossiible(mid, arr);
            if(count > m){
                // ans = mid;
                start = mid+1;
                
            }
            else{
                end = mid-1;
            }
        }
        return start;
    }
}
