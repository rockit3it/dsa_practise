basic operations
1)right shift
4>>1
4/2^1


2) to clear the right most set bit
n = n&(n-1)
3) to get clear the 3rd bit from left
10111 --> 10011
1<<3
n = n &~(1<<3)

4) to set 4th bit
10111 --> 11111

1 << 3
n = n | 1 << 3

5) for swapping of two numbers a = 5 b = 6 -> a = 6, b = 5
a = a^b
a = 5^6
b = a^b = 5^6^5 = 6
a = a^b = 5^6^5 = 6;

6)
to check the ith bit is set or not 
we can directly shit the number by i right shift

7)Count total set bits
N = 4
ans = 5
001
010
011
100
= 5
 observation
Decimal	E	D	C	B	A
0	0	0	0	0	0
1	0	0	0	0	1
2	0	0	0	1	0
3	0	0	0	1	1
4	0	0	1	0	0
5	0	0	1	0	1
6	0	0	1	1	0
7	0	0	1	1	1
8	0	1	0	0	0
9	0	1	0	0	1
10	0	1	0	1	0
11	0	1	0	1	1
12	0	1	1	0	0
13	0	1	1	0	1
14	0	1	1	1	0
15	0	1	1	1	1
16	1	0	0	0	0

for first column for sample size 2 there is one set bit so if we have number 4 take it as 5 we will observe the pattern from 0000 so number is 5/2 = 4 in integer it is 
not completely divisible by 2 so we take modulo of 5%2 = 1 it is not greater that pattern size/2 so we not take if opposite caase is their we take it
code:
class Solution{
    
    //Function to return sum of count of set bits in the integers from 1 to n.
    public static int countSetBits(int n){
        // Your code here
        int patSize = 2;
        int sbit = 1;
        int count = 0;
        int k = 0;
        n++;
        for(int j = 1; j <= n; j = j*2){
            k = n/patSize;
            k *= sbit;
            // System.out.println(k);
            count += k;
            k = n%patSize;
            if(k > patSize/2){
                count = count + (k-patSize/2);
            }
            sbit = sbit * 2;
            patSize = 2*patSize;
        }
        return count;
    }
}


8) how to check if a number if power of two:
by one observation that if any number is power of two means there will be only one set bit
and we can check that by doing n&(n-1) do it until n becomes 0


9) 	
Count number of bits to be flipped to convert A to B
class Solution {
    public int minBitFlips(int start, int goal) {
        int Xor = start ^ goal;
        int count = 0;
        while(Xor != 0){
            Xor = Xor & (Xor-1);
            count++;
        }
        return count;
    }
}
10) to find the xor of values from 1 to n
value Xor
1      1
1^2    3
1^2^3  0
1^2^3^4 4

1^2^3^4^5 1
1^2^3^4 4^5^6 7
1^2^3^4 4^5^6^7 0
1^2^3^4 4^5^6^7^8 8


from here we can observe a pattern that if any 
number % 4 == 1 the xor will be 1
number % 4 == 2 the xor will be number+1
number % 4 == 3 the xor will be 0
number % 4 == 4 the xor will be number it self

by the same method we can also find the xor from the l to r

l = 4 r = 8
we will find int a = xor of 1 to 4
and we will find int b = xor of 1 to 8
again we will take xor of both
int ans = a^b;

code:
class Solution {
    public static int findXOR(int l, int r) {
        int mod = 0;
        if((l-1 )% 4 == 1){
            mod = 1;
        }
        if((l-1) % 4 == 2){
            mod = l;
        }
        if((l-1) % 4 == 0){
            mod = l-1;
        }
        if(r % 4 == 1){
            return 1^mod;
        }
        if(r % 4 == 2){
            return (r+1)^mod;
        }
        if(r % 4 == 3){
            return 0^mod;
        }
        return r^mod;
    }
}


11) to find the subarrays of a array 
Given an integer array nums of unique elements, return all possible 
subsets
 (the power set).

The solution set must not contain duplicate subsets. Return the solution in any order.

 

Example 1:

Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
Example 2:

Input: nums = [0]
Output: [[],[0]]

in this question the observation is the total subarrays will be 2^n if n is the size of array
000
001
010
011
100
101
110
111
means for size 3 we will running the loop for 0 to 2^n means 1<<n times and where ever 0 occurs from left to right in binary numbers then not take it 1 take that index .lsb represents oth index of array

code:


class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> al = new ArrayList<>();
        for(int i = 0; i < (1<<nums.length); i++){
            List<Integer> temp = new ArrayList<>();
            int idx = 0;
            int num = i;
            while(num != 0){
                if((num & 1) == 1){
                    temp.add(nums[idx]);
                }
                idx++;
                num = num >> 1;
            }
            al.add(temp);
        }
        return al;
    }
}
