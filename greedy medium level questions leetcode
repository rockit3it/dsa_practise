502. IPO
Solved
Hard
Topics
Companies
Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.

You are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.

Initially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.

Pick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.

The answer is guaranteed to fit in a 32-bit signed integer.

code:
import java.util.*;

class Solution {
    class Pair {
        int profit;
        int cap;
        
        public Pair(int profit, int cap) {
            this.profit = profit;
            this.cap = cap;
        }
    }
    
    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        List<Pair> al = new ArrayList<>();
        for (int i = 0; i < profits.length; i++) {
            al.add(new Pair(profits[i], capital[i]));
        }
        al.sort((a, b) -> Integer.compare(a.cap, b.cap));
        
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        
        int i = 0;
        while (k > 0) {
            while (i < al.size() && al.get(i).cap <= w) {
                pq.add(al.get(i).profit);
                i++;
            }
            if (pq.isEmpty()) break;
            
            // Choose the project with the maximum profit from pq
            w += pq.poll();
            k--;
        }

   return w;
    }
}
330. Patching Array
Solved
Hard
Topics
Companies
Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.

Return the minimum number of patches required.
code:
Input: nums = [1,3], n = 6
Output: 1
Explanation:
Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.
Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].
Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].
So we only need 1 patch.
Example 2:

Input: nums = [1,5,10], n = 20
Output: 2
Explanation: The two patches can be [2, 4].


code:
class Solution {
    public int minPatches(int[] nums, int n) {
        long maxReach = 0;
        int count = 0;
        int i = 0;
        while(maxReach < n){
            if(i < nums.length && nums[i] <= maxReach+1){
                maxReach += nums[i];
                i++;
            }
            else{
                maxReach += maxReach + 1;
                count++;
            }
        }
        return count;
    }
}


826. Most Profit Assigning Work

two approaches:
i) one can be solved by using normal sorting of both worker array and profit array this is done by me with tc of O(nlongn + mlogm)
2) this can be solved using make a array of size maxof profit + 1
code:

class Solution {
    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {
        int maxProfit = Arrays.stream(worker).max().getAsInt();
        int jobs[] = new int[maxProfit+1];
        for(int i = 0; i < difficulty.length; i++){
            if(difficulty[i] <= maxProfit){
                jobs[difficulty[i]] = Math.max(jobs[difficulty[i]], profit[i]); // this for if any repeating job but with diffrent profit so we will take only maximum profit among them
            }
        }
        for(int i = 1; i < jobs.length; i++){
            jobs[i] = Math.max(jobs[i], jobs[i-1]); // this is to store the max value upto now as if current index of difficulty is lets say 10(difficulty[i] = 10) then the difficulty less than this will also valid so we take maximum upto current difficulty[i]
        }
        int netProfit = 0;
        for(int i = 0; i < worker.length; i++){
            netProfit += jobs[worker[i]];
        }
        return netProfit;
    }
}
     
995. Minimum Number of K Consecutive Bit Flips

ou are given a binary array nums and an integer k.

A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.

Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.

A subarray is a contiguous part of an array.

 

Example 1:

Input: nums = [0,1,0], k = 1
Output: 2
Explanation: Flip nums[0], then flip nums[2].


code:
class Solution {
    public int minKBitFlips(int[] nums, int k) {
        // flipped count array we have used for storing the subarrays particular index is flipped or not
        int flippedCount[] = new int[nums.length];
        int timesFlipped = 0;
        int ans = 0;
        for(int i = 0; i < nums.length; i++){
            // this is to reduce the flipped times to reduce the current flips to previousFlipps-currFlips->> here currFlips is refring to flip count
            if(i >= k){
                timesFlipped -= flippedCount[i-k];
            }
            // if flipp count is 1 or odd then 1-> 0 here we need to flip 1->0 to convert 1->1 1->0->1
            // if flipp count is 2 or even then 0->1 here we need to flip 0->1
            if(timesFlipped%2 == 1 && nums[i] == 1 || timesFlipped%2 == 0 && nums[i] == 0){
                if(i+k > nums.length) return -1;
                timesFlipped++;
                flippedCount[i] = 1;
                ans++;
            }
        } 
        return ans;
    }
}


JumpGame 1:
55. Jump Game
Solved
Medium
Topics
Companies
You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.

Return true if you can reach the last index, or false otherwise.

 

Example 1:

Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:

Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index

solution:

class Solution {
    public boolean canJump(int[] nums) {
        int max = 0;
        for(int i = 0; i < nums.length; i++){
            if(i > max){
                return false;
            }
            max = Math.max(nums[i]+i, max);
        }
        return true;
    }
}
