Note:
1) to find number of subarray sum = k for that we can find the number of (subarray with sum at most k) - (number of subarray with sum k-1)
2) to find the number of subarray we do j-i+1
similar as binary subarray problem

1248. Count Number of Nice Subarrays
Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.

Return the number of nice sub-arrays.

 

Example 1:

Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].

class Solution {
    public int atMost(int k, int[] nums){
        int left = 0;
        int right = 0;
        int sum = 0;
        int count = 0;
        while(right < nums.length){
            sum += nums[right]%2;
            while(left < nums.length && sum > k){
                sum -= nums[left]%2;
                left++;
            }
            count += right-left+1;
            right++;
        }
        return count;
    }
    public int numberOfSubarrays(int[] nums, int k) {
        return atMost(k, nums) - atMost(k-1, nums);
    }
}



1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit
Example 1:

Input: nums = [8,2,4,7], limit = 4
Output: 2 
Explanation: All subarrays are: 
[8] with maximum absolute diff |8-8| = 0 <= 4.
[8,2] with maximum absolute diff |8-2| = 6 > 4. 
[8,2,4] with maximum absolute diff |8-2| = 6 > 4.
[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.
[2] with maximum absolute diff |2-2| = 0 <= 4.
[2,4] with maximum absolute diff |2-4| = 2 <= 4.
[2,4,7] with maximum absolute diff |2-7| = 5 > 4.
[4] with maximum absolute diff |4-4| = 0 <= 4.
[4,7] with maximum absolute diff |4-7| = 3 <= 4.
[7] with maximum absolute diff |7-7| = 0 <= 4. 
Therefore, the size of the longest subarray is 2


code:
class Solution {
    public int longestSubarray(int[] nums, int limit) {
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        int i = 0;
        int length = Integer.MIN_VALUE;
        while(i < nums.length){
            min = Math.min(nums[i], min);
            max = Math.max(nums[i], max);
            int j = i;
            while(j < nums.length && (max-min) <= limit){
                j++;
                if(j < nums.length){
                    min = Math.min(nums[j], min);
                    max = Math.max(nums[j], max);
                }
            }
            length = Math.max((j-i), length);
            if(j == nums.length){
                return length;
            }
            if(min == nums[i]){
                min = Integer.MAX_VALUE;
            }
            if(max == nums[i]){
                max = Integer.MIN_VALUE;
            }
            i++;
        }
        return length;
    }
}
