Note: this method is applied to those type  of questions where we have to find either sum of subarray is something or we need to find count of something or any operation on the subarray this can be solve by using sliding windows as well


930. Binary Subarrays With Sum
Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.

A subarray is a contiguous part of the array.

 

Example 1:

Input: nums = [1,0,1,0,1], goal = 2
Output: 4
Explanation: The 4 subarrays are bolded and underlined below:
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]

code:
class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        HashMap<Integer, Integer> hm = new HashMap<>();
        hm.put(0, 1);
        int sum = 0;
        int count = 0;
        for(int i = 0; i < nums.length; i++){
            sum += nums[i];
            if(hm.containsKey(sum-goal)){
                count += hm.get(sum-goal);
            }
            hm.put(sum, hm.getOrDefault(sum, 0)+1);
        }
        return count;
    }
}

1248. Count Number of Nice Subarrays

Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.

Return the number of nice sub-arrays.

 

Example 1:

Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].
Example 2:

Input: nums = [2,4,6], k = 1
Output: 0
Explanation: There are no odd numbers in the array.

code:
class Solution {
    public int numberOfSubarrays(int[] nums, int k) {
        HashMap<Integer, Integer> hm = new HashMap<>();
        hm.put(0, 1);
        int count = 0;
        int sum = 0;
        for(int i = 0; i < nums.length; i++){
            if((nums[i] & 1) == 1){
                count++;
            }
            if(hm.containsKey(count-k)){
                sum += hm.get(count-k);
            }
            hm.put(count, hm.getOrDefault(count, 0)+1);
        } 
        return sum;
    }
}
